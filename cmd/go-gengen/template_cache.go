package main

// CacheTemplate is template for cache generation
const CacheTemplate = `// Code generated by go-gengen(v0.0.1) DO NOT EDIT.

package {{.Package}}

import ({{range .Stdlib}}
	"{{.}}"{{end}}{{if .Remote}}
{{range .Remote}}
	"{{.}}"{{end}}{{end}}
)

// Cache is an observable concurrent in-memory datastore
type Cache struct {
	dat   map[{{.Key}}]{{.Val}}
	mu    sync.Mutex
	obs   []Func
}

// Storer is an abstraction of in-memory datastore
type Storer interface {
	Get({{.Key}}) {{.Val}}
	Set({{.Key}}, {{.Val}})
	Each(Func)
	Sync(func(map[{{.Key}}]{{.Val}}))
	Keys() []{{.Key}}
	Observe(Func)
	Remove({{.Key}})
}

// Func is a callback func
type Func = func({{.Key}}, {{.Val}})

// NewCache returns a new Cache
func NewCache() *Cache {
	return &Cache{
		dat: make(map[{{.Key}}]{{.Val}}),
		obs:   make([]Func, 0),
	}
}

// Get returns the {{.Val}} for a {{.Key}}
func (c *Cache) Get(k {{.Key}}) {{.Val}} { return c.dat[k] }

// Set saves a {{.Val}} for a {{.Key}}
func (c *Cache) Set(k {{.Key}}, v {{.Val}}) {
	c.mu.Lock()
	if v != nil {
		c.dat[k] = v
	} else {
		delete(c.dat, k)
	}
	c.mu.Unlock()
	for _, f := range c.obs {
		f(k, v)
	}
}

// Each calls the func for each {{.Key}},{{.Val}} in this Cache
func (c *Cache) Each(f Func) {
	c.mu.Lock()
	for k, v := range c.dat {
		f(k, v)
	}
	c.mu.Unlock()
}

// Sync calls the func within the cache lock state
func (c *Cache) Sync(f func(map[{{.Key}}]{{.Val}})) {
	c.mu.Lock()
	f(c.dat)
	c.mu.Unlock()
}

// Keys returns a new slice with all the {{.Key}} keys
func (c *Cache) Keys() []{{.Key}} {
	c.mu.Lock()
	keys := make([]{{.Key}}, 0, len(c.dat))
	for k := range c.dat {
		keys = append(keys, k)
	}
	c.mu.Unlock()
	return keys
}

// Observe adds a func to be called when a {{.Val}} is explicitly set
func (c *Cache) Observe(f Func) { c.obs = append(c.obs, f) }

// Remove deletes a {{.Key}},{{.Val}}
func (c *Cache) Remove(k {{.Key}}) { c.Set(k, nil) }
`
